1.volatile
20200902

问题： 请谈谈你对volatile的理解？

1.volatile是轻量级的同步机制
	保证可见性
	不保证原子性
	禁止指令重排

	单线程不需要考虑指令重排（单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致）
	多线程要考虑指令重排 （多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测）

2.JMM要保证 － 可见性，原子性，有序性
	主内存
	线程的工作内存

	线程会复制主内存中的 变量值到“线程的工作内存”中，修改完后会写回到主内存，JMM的可见性机制会让其他线程知道这个值已经发生改变
	
	只有工作内存失效的时候。工作内存才会重新加载主内存的变量

	工作内存的变量会失效的时机：
		线程中释放锁时，
		线程切换时，
		CPU有空闲时间时（比如线程休眠，IO操作）
	即（	.	
		在方法中调用同步方法 比如System.out.println();
		线程休眠sleep(1000);
		IO操作 File file = new File(“D://temp.txt”);
		）

System.out.println()中有synchronized
线程欲进入synchronized时，会执行以下两类操作： 强制写入主存储器（main memory） 当线程欲进入synchronized时，如果该线程的工作存储器（working memory）上有未映像到主存储器的拷贝，则这些内容会强制写入主存储器（store->write），则这些计算结果就会对其它线程可见（visible）。 工作存储器（working memory）的释放 当线程欲进入synchronized时，工作存储器上的工作拷贝会被全部丢弃。之后，欲引用主存储器上的值的线程，必定会从主存储器将值拷贝到工作拷贝（read->load）